1) 
--Сначала оставьте только те объявления, в которых оценка на основе отзывов выше среднего, а число отзывов в месяц составляет строго меньше трёх. 
--Затем отсортируйте по убыванию две колонки: сначала по числу отзывов в месяц, потом по оценке. В качестве ответа укажите id объявления из первой строки.

--review_scores_rating – оценка на основе отзывов String
--reviews_per_month – число отзывов в месяц float32
--id – идентификатор объявления
--Таблица – listings. Наивысшие показатели = сортировка по убыванию.
SELECT
    toFloat32OrNull(review_scores_rating) as rsr, -- надо обязательно сделть второе преобразование, чтобы мы могли сравнить потом это в блоке WHERE
    reviews_per_month,
    id
FROM listings
WHERE 
    rsr >
        (SELECT 
            AVG(toFloat64OrNull(review_scores_rating))
        FROM listings)
    AND
        reviews_per_month < 3 
ORDER BY reviews_per_month DESC, rsr DESC
LIMIT 10

2)
--Посчитайте среднее расстояние до центра города и выведите идентификаторы объявлений о сдаче отдельных комнат, для которых расстояние оказалось меньше среднего.
--Результат отсортируйте по убыванию, тем самым выбрав комнату, которая является наиболее удаленной от центра, но при этом расположена ближе, чем остальные комнаты в среднем. 

--id – идентификатор объявления
--host_id – идентификатор хозяина
--room_type – тип жилья ('Private room')
--latitude – широта String
--longitude – долгота String
--52.5200 с.ш., 13.4050 в.д – координаты центра Берлина
--В качестве ответа укажите идентификатор хозяина (host_id), сдающего данную комнату.

--geoDistance(13.4050, 52.5200, долгота, широта)
--Note: задание можно решить как используя подзапрос в WHERE, так и с помощью WITH. При подсчете среднего тип комнаты тоже следует учесть.
SELECT 
    id,
    host_id,
    geoDistance(13.4050, 52.5200, toFloat32OrNull(longitude), toFloat32OrNull(latitude)) as dist_m

FROM listings

WHERE
    dist_m < 
        (SELECT
            AVG(geoDistance(13.4050, 52.5200, toFloat32OrNull(longitude), toFloat32OrNull(latitude)))
        FROM listings
        WHERE room_type = 'Private room')
        
    AND room_type = 'Private room'
    
ORDER BY dist_m DESC

LIMIT 10

 ИЛИ можно еще так с WITH:
WITH 
    (
    SELECT avg(geoDistance(13.4050, 52.5200, toFloat32OrNull(longitude), toFloat32OrNull(latitude)))
    FROM listings
    WHERE room_type  = 'Private room'
    ) AS avg_distance

SELECT 
    id,
    host_id,
    geoDistance(13.4050, 52.5200, toFloat32OrNull(longitude), toFloat32OrNull(latitude)) as dist_m

FROM listings

WHERE
    dist_m < avg_distance AND room_type = 'Private room'
    
ORDER BY dist_m DESC

3)
--Представим, что вы планируете снять жилье в Берлине на 7 дней, используя более хитрые фильтры, чем предлагаются на сайте.

--В этой задаче можно потренироваться в написании подзапросов, но задание можно решить и без них.

--Отберите объявления из таблицы listings, которые:

--находятся на расстоянии от центра меньше среднего (здесь нам пригодится запрос из предыдущего задания)
--обойдутся дешевле 100$ в день (price с учетом cleaning_fee, который добавляется к общей сумме за неделю, т.е его нужно делить на кол-во дней)
--имеют последние отзывы (last_review), начиная с 1 сентября 2018 года
--имеют WiFi в списке удобств (amenities)
--Отсортируйте полученные значения по убыванию review_scores_rating (не забудьте перевести строку к численному виду) и в качестве ответа укажите host_id из первой строки. 

--Hint: документация по функции multiSearchAnyCaseInsensitive(колонка, ['искомая_подстрока']), которая ищет заданную подстроку в строке вне зависимости от 
--регистра и выдает 0 в случае, если подстрока не была найдена
SELECT
    last_review,
    amenities,
    host_id,
    toFloat64OrNull(review_scores_rating) AS review_scores_rating,
    toFloat32OrNull(replaceRegexpAll(price, '[$,]', '')) AS price,
    geoDistance(13.4050, 52.5200, toFloat32OrNull(latitude), toFloat32OrNull(longitude)) as dist_m,
    toStartOfMonth(toDateOrNull(last_review)) as last_review
    
FROM listings

WHERE price = (SELECT ((toFloat32OrNull(replaceRegexpAll(price, '[$,]', '')) + (toFloat32OrNull(replaceRegexpAll(cleaning_fee, '[$,]', '')))/7)) AS price_per_cleaning
    FROM listings
    LIMIT 1
    ) < 100 AND multiSearchAnyCaseInsensitive(amenities, ['Wifi']) 
    AND dist_m < (SELECT AVG(geoDistance(13.4050, 52.5200, toFloat32OrNull(latitude), toFloat32OrNull(longitude)))
    FROM listings)
    AND last_review = '2018-09-01'

ORDER BY review_scores_rating DESC
LIMIT 10

4) 
--Давайте найдем в таблице calendar_summary те доступные (available='t') объявления, у которых число отзывов от уникальных пользователей в таблице reviews выше среднего.

--NB! Для простоты будем считать, что отзыв — это уникальный посетитель на уникальное жилье, не учитывая возможные повторные отзывы от того же посетителя.

--Для этого с помощью конструкции WITH посчитайте среднее число уникальных reviewer_id из таблицы reviews на каждое жильё, потом проведите джойн таблиц calendar_summary и reviews по полю listing_id (при этом из таблицы calendar_summary должны быть отобраны уникальные listing_id, отфильтрованные по правилу available='t'). Результат отфильтруйте так, чтобы остались только записи, у которых число отзывов от уникальных людей выше среднего.

--Отсортируйте результат по возрастанию listing_id и в качестве ответа впишите количество отзывов от уникальных пользователей из первой строки.

--Hint: для решения проблем со вложенными агрегационными функциями (и агрегационными функциями там, где их не ждут) как раз очень помогут подзапросы.
WITH  
(SELECT
    AVG(reviewers)
FROM
    (SELECT 
        listing_id,
        count(DISTINCT reviewer_id) AS reviewers
    FROM reviews as r
    INNER JOIN (
        SELECT 
            DISTINCT listing_id
        FROM calendar_summary
        WHERE available = 't') AS c 
    ON r.listing_id = c.listing_id
    GROUP BY listing_id)) AS avg_reviewers

SELECT  
    listing_id,
    count(reviewer_id) as reviewers
FROM reviews as r
INNER JOIN
    (
    SELECT  
        DISTINCT listing_id
    FROM calendar_summary
    WHERE available = 't'
    ) AS c
ON r.listing_id = c.listing_id
GROUP BY listing_id
HAVING reviewers > avg_reviewers
ORDER BY listing_id
LIMIT 1
